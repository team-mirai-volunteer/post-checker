# dify-cli sync コマンド設計書

## 目的

開発者・運用担当者が、ローカル開発環境やCI上で Dify の Knowledge Base をリポジトリの内容と同期できるようにするため。

これにより：
- ローカルのMarkdownファイルを編集→Difyに即反映のワークフローが可能に
- CI/CDでmainマージ時に本番Difyへ自動反映ができる
- ナレッジのバージョン管理がGitで行える

## コマンド仕様

### 基本コマンド

```bash
npm run dify sync
```

### 環境変数

| 変数名 | 必須 | 説明 | 例 |
|--------|------|------|-----|
| `DIFY_API_URL` | Yes | DifyサーバーのベースURL | `http://localhost` / `https://knowledge.team-mir.ai` |
| `DIFY_API_KEY` | Yes | Knowledge API用のAPIキー | `dataset-xxx...` |

### 設定ファイル

`dify/sync.yaml` に、ディレクトリとKnowledge Baseのマッピングを一元管理する。

**`dify/sync.yaml`**

```yaml
# ディレクトリ → Knowledge Base のマッピング
datasets:
  - path: knowledges/manifesto
    dataset_id: "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    # 処理設定（任意）
    indexing_technique: high_quality  # high_quality | economy
    process_rule:
      mode: automatic  # automatic | custom

  - path: knowledges/note
    dataset_id: "yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy"

  - path: knowledges/video-transcripts
    dataset_id: "zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz"
```

### 同期アルゴリズム

1. `dify/sync.yaml` を読み込み、マッピング一覧を取得
2. 各ディレクトリについて：
   1. Dify APIでそのKnowledge Baseの既存ドキュメント一覧を取得
   2. ローカルの `.md` ファイル一覧を取得
   3. 比較して差分を算出：
      - **新規**: ローカルにあってDifyにないファイル → `create_by_text`
      - **更新**: 両方にあるがハッシュが異なる → `update_by_text`
      - **削除**: Difyにあってローカルにないファイル → `delete`
      - **変更なし**: スキップ
3. 差分操作を順次実行

### ファイル→ドキュメントのマッピング

| ローカルファイル | Difyドキュメント名 | 識別方法 |
|------------------|-------------------|----------|
| `01_チームみらいのビジョン.md` | `01_チームみらいのビジョン.md` | ファイル名で一致判定 |

Difyのドキュメント `name` フィールドにローカルのファイル名を設定し、それをキーとして同一性を判定する。

### 変更検知

更新判定のために、ファイル内容のハッシュ（SHA-256など）をDifyドキュメントのメタデータに保存する。

```
metadata:
  source_hash: "abc123..."
  synced_at: "2026-01-20T00:28:00Z"
```

### 出力例

```
$ npm run dify sync

Syncing knowledges/manifesto/ → dataset: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  [CREATE] 01_チームみらいのビジョン.md
  [UPDATE] 02_政策インデックス.md (hash changed)
  [SKIP]   10_ステップ１「デジタル時代の当たり前をやりきる」.md
  [DELETE] old_document.md

Sync complete: 1 created, 1 updated, 28 unchanged, 1 deleted
```

### エラーハンドリング

- `DIFY_API_URL` / `DIFY_API_KEY` 未設定 → エラーで終了
- `dify/sync.yaml` が存在しない → エラーで終了
- `dataset_id` が無効 → そのエントリをスキップし警告
- API呼び出し失敗 → リトライ後、失敗したファイルを報告して継続

## 利用するDify API

| 操作 | エンドポイント | メソッド |
|------|---------------|----------|
| ドキュメント一覧取得 | `/v1/datasets/{dataset_id}/documents` | GET |
| テキストからドキュメント作成 | `/v1/datasets/{dataset_id}/document/create_by_text` | POST |
| テキストでドキュメント更新 | `/v1/datasets/{dataset_id}/documents/{document_id}/update_by_text` | POST |
| ドキュメント削除 | `/v1/datasets/{dataset_id}/documents/{document_id}` | DELETE |

## CI/CD連携

GitHub Actionsでの利用例：

```yaml
- name: Sync knowledge to Dify
  env:
    DIFY_API_URL: ${{ secrets.DIFY_API_URL }}
    DIFY_API_KEY: ${{ secrets.DIFY_API_KEY }}
  run: npm run dify sync
```

## ディレクトリ構成

```
post-checker-proto/
├── dify/
│   ├── sync.yaml           # ← 同期設定（1ファイルで一元管理）
│   └── workflows/
└── knowledges/             # ← 純粋なナレッジのみ（dify設定なし）
    ├── manifesto/
    │   ├── 01_チームみらいのビジョン.md
    │   └── ...
    ├── note/
    │   └── ...
    └── video-transcripts/
        └── ...
```

## 依存関係

- 既存: `tsx`
- 追加予定: なし（Node.js標準のfetchで実装可能）

## プログラム設計

### アーキテクチャ

3層構成（依存逆転・ドメイン層なし）:

```
┌─────────────────────────────────────────────────────┐
│  CLI Layer                                          │
│  - コマンドライン引数のパース                         │
│  - 環境変数の読み込み                                │
│  - 進捗・結果の表示                                  │
└─────────────────────┬───────────────────────────────┘
                      │ 呼び出し
                      ▼
┌─────────────────────────────────────────────────────┐
│  Usecase Layer                                      │
│  - 設定ファイルの読み込み                            │
│  - ローカルファイルの走査                            │
│  - 差分計算ロジック                                  │
│  - 同期オーケストレーション                          │
└─────────────────────┬───────────────────────────────┘
                      │ 呼び出し
                      ▼
┌─────────────────────────────────────────────────────┐
│  Client Layer                                       │
│  - Dify API呼び出し                                 │
│  - HTTP通信・リトライ                               │
│  - レスポンスのパース                               │
└─────────────────────────────────────────────────────┘
```

### ファイル構成

```
scripts/
├── src/
│   ├── dify-cli.ts             # エントリポイント（CLI Layer）
│   ├── usecase/
│   │   ├── sync.ts             # 同期オーケストレーション
│   │   └── diff.ts             # 差分計算
│   └── client/
│       └── knowledge.ts        # Dify Knowledge API クライアント
└── test/
    ├── usecase/
    │   ├── sync.test.ts        # Usecaseテスト（モック）
    │   └── diff.test.ts        # 差分計算テスト（純粋関数）
    └── client/
        └── knowledge.test.ts   # Clientテスト（モック + 統合テスト）
```

### 各層の責務

#### CLI Layer (`src/dify-cli.ts`)

```
責務:
- process.argv からサブコマンド・オプションをパース
- 環境変数 DIFY_API_URL, DIFY_API_KEY を取得
- Usecase を呼び出し
- 結果を標準出力に表示（進捗、成功、エラー）
- 終了コードを返す（成功: 0, エラー: 1）

依存:
- usecase/sync.ts
```

#### Usecase Layer

**`usecase/sync.ts`**
```
責務:
- dify/sync.yaml を読み込み・パース
- 各 dataset について:
  - ローカルの .md ファイル一覧を取得
  - Client 経由で Dify のドキュメント一覧を取得
  - diff.ts で差分を計算
  - 差分に基づき Client の create/update/delete を呼び出し
- 同期結果（件数）を返す

依存:
- usecase/diff.ts
- client/knowledge.ts
```

**`usecase/diff.ts`**
```
責務:
- ローカルファイル一覧と Dify ドキュメント一覧を比較
- 各ファイルについて CREATE / UPDATE / DELETE / SKIP を判定
- ハッシュ計算（SHA-256）

依存:
- なし（純粋関数）
```

#### Client Layer (`client/knowledge.ts`)

```
責務:
- Dify Knowledge API の HTTP 呼び出しをラップ
- 認証ヘッダーの付与
- エラーハンドリング・リトライ
- レスポンスの型付け

公開メソッド:
- listDocuments(datasetId): Promise<Document[]>
- createDocument(datasetId, name, text, options?): Promise<Document>
- updateDocument(datasetId, documentId, name, text): Promise<Document>
- deleteDocument(datasetId, documentId): Promise<void>

依存:
- fetch（Node.js標準）
```

### 型定義

```typescript
// 設定ファイルの型
interface SyncConfig {
  datasets: DatasetConfig[];
}

interface DatasetConfig {
  path: string;
  dataset_id: string;
  indexing_technique?: "high_quality" | "economy";
  process_rule?: { mode: "automatic" | "custom" };
}

// 差分計算の結果
type DiffAction = "create" | "update" | "delete" | "skip";

interface DiffResult {
  action: DiffAction;
  filename: string;
  localPath?: string;      // create/update時
  documentId?: string;     // update/delete時
  reason?: string;         // "hash changed" など
}

// Dify API レスポンス
interface DifyDocument {
  id: string;
  name: string;
  // ... 他のフィールド
}
```

### 設計判断

| 項目 | 判断 | 理由 |
|------|------|------|
| 依存逆転（DI） | 不採用 | Dify以外のバックエンドを想定しないため過剰 |
| ドメイン層 | 不採用 | ビジネスロジックが単純（差分計算のみ）で、Usecase内で十分 |
| インターフェース分離 | 不採用 | Client が1つしかなく、テスト時はモック関数で対応 |
| エラー型 | Result型ではなく例外 | シンプルさ優先。CLI で catch してログ出力 |

## テスト設計

### テスト構成

```
scripts/
├── src/
│   ├── usecase/
│   │   ├── sync.ts
│   │   └── diff.ts
│   └── client/
│       └── knowledge.ts
└── test/
    ├── usecase/
    │   ├── sync.test.ts        # Usecaseテスト（モック）
    │   └── diff.test.ts        # 差分計算テスト（純粋関数）
    └── client/
        └── knowledge.test.ts   # Clientテスト（モック + 統合テスト）
```

### テスト実行

```bash
# 全テスト（モックのみ）
npm test

# 統合テストを含む（localhost の Dify に接続）
INTEGRATION_TEST=true npm test
```

### 各層のテスト方針

#### Client Layer (`client/knowledge.test.ts`)

**ユニットテスト（常時実行）**

fetch をモックし、リクエスト・レスポンスの形式を検証。

```
テストケース:
- listDocuments
  - 正常系: ドキュメント一覧を取得できる
  - 正常系: ページネーション（複数ページ）を処理できる
  - 異常系: 401 で認証エラーを返す
  - 異常系: 404 で dataset not found エラーを返す
  - 異常系: 500 でリトライ後に失敗する

- createDocument
  - 正常系: ドキュメントを作成できる
  - 正常系: オプション（indexing_technique等）が渡される
  - 異常系: 400 でバリデーションエラーを返す

- updateDocument
  - 正常系: ドキュメントを更新できる
  - 異常系: 404 で document not found エラーを返す

- deleteDocument
  - 正常系: ドキュメントを削除できる
  - 異常系: 404 で document not found エラーを返す

- 共通
  - Authorization ヘッダーが正しく設定される
  - ベースURLが正しく構築される
  - リトライロジック（5xx エラー時）
```

**統合テスト（INTEGRATION_TEST=true 時のみ）**

実際の localhost Dify に対してAPIを呼び出し、E2Eで検証。

```
前提条件:
- DIFY_API_URL=http://localhost（またはテスト用URL）
- DIFY_API_KEY=有効なAPIキー
- テスト用 dataset_id が存在する

テストケース:
- listDocuments: 実際にドキュメント一覧を取得
- createDocument → listDocuments: 作成したドキュメントが一覧に含まれる
- createDocument → updateDocument: 更新後に内容が変わっている
- createDocument → deleteDocument → listDocuments: 削除後に一覧から消える
- 存在しない dataset_id でエラー

後処理:
- テストで作成したドキュメントをクリーンアップ
```

#### Usecase Layer

**`diff.test.ts`（純粋関数テスト）**

```
テストケース:
- 新規ファイルの検出
  - ローカルにあって Dify にない → CREATE
- 更新ファイルの検出
  - 両方にあり、ハッシュが異なる → UPDATE
- 削除ファイルの検出
  - Dify にあってローカルにない → DELETE
- 変更なしの検出
  - 両方にあり、ハッシュが同じ → SKIP
- 複合ケース
  - 複数ファイルで CREATE/UPDATE/DELETE/SKIP が混在
- エッジケース
  - ローカルが空（全削除）
  - Dify が空（全新規）
  - 両方空（何もしない）
```

**`sync.test.ts`（オーケストレーションテスト）**

Client をモックし、sync.yaml の読み込みから差分適用までのフローを検証。

```
テストケース:
- 正常系
  - 設定ファイルを読み込み、各 dataset を処理する
  - CREATE/UPDATE/DELETE が正しく Client に渡される
  - 同期結果（件数）が正しく返される
- 異常系
  - sync.yaml が存在しない → エラー
  - sync.yaml のパースエラー → エラー
  - 指定パスが存在しない → 警告してスキップ
  - Client エラー時 → エラー報告して継続
```

### 統合テストの環境変数

| 変数名 | 必須 | 説明 | デフォルト |
|--------|------|------|-----------|
| `INTEGRATION_TEST` | No | `true` で統合テストを実行 | 未設定（スキップ） |
| `DIFY_API_URL` | 統合テスト時 | テスト対象のDify URL | `http://localhost` |
| `DIFY_API_KEY` | 統合テスト時 | テスト用APIキー | - |
| `DIFY_TEST_DATASET_ID` | 統合テスト時 | テスト用のdataset ID | - |

### 統合テストの実装パターン

```typescript
// knowledge.test.ts

describe("KnowledgeClient", () => {
  // ユニットテスト（常時実行）
  describe("unit", () => {
    it("listDocuments - 正常系", async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ data: [...] }),
      });
      // ...
    });
  });

  // 統合テスト（INTEGRATION_TEST=true 時のみ）
  describe.skipIf(!process.env.INTEGRATION_TEST)("integration", () => {
    let createdDocIds: string[] = [];

    afterEach(async () => {
      // クリーンアップ: テストで作成したドキュメントを削除
      for (const id of createdDocIds) {
        await client.deleteDocument(datasetId, id);
      }
      createdDocIds = [];
    });

    it("create → list → delete の一連のフロー", async () => {
      const doc = await client.createDocument(datasetId, "test.md", "content");
      createdDocIds.push(doc.id);

      const list = await client.listDocuments(datasetId);
      expect(list.some(d => d.id === doc.id)).toBe(true);

      await client.deleteDocument(datasetId, doc.id);
      createdDocIds = createdDocIds.filter(id => id !== doc.id);

      const listAfter = await client.listDocuments(datasetId);
      expect(listAfter.some(d => d.id === doc.id)).toBe(false);
    });
  });
});
```

### テストフレームワーク

- **vitest**: 高速でTypeScriptネイティブ対応
- `describe.skipIf` で統合テストの条件付きスキップが簡潔に書ける
